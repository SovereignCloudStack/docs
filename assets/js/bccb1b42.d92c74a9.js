"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[56986],{68002:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"container/components/container-registry/docs/migration","title":"Migration","description":"harbormigration.png","source":"@site/docs/03-container/components/container-registry/docs/migration.md","sourceDirName":"03-container/components/container-registry/docs","slug":"/container/components/container-registry/docs/migration","permalink":"/docs/container/components/container-registry/docs/migration","draft":false,"unlisted":false,"editUrl":"https://github.com/SovereignCloudStack/docs/tree/main/docs/03-container/components/container-registry/docs/migration.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Backup and restore","permalink":"/docs/container/components/container-registry/docs/backup_and_restore"},"next":{"title":"Persistence","permalink":"/docs/container/components/container-registry/docs/persistence"}}');var s=r(74848),o=r(28453);const i={},a="Migration",c={},l=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Kubernetes clusters",id:"kubernetes-clusters",level:3},{value:"S3 bucket and EC2 credentials",id:"s3-bucket-and-ec2-credentials",level:3},{value:"Velero client",id:"velero-client",level:3},{value:"Velero server",id:"velero-server",level:3},{value:"Migration",id:"migration-1",level:2}];function d(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"migration",children:"Migration"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"harbor_migration.png",src:r(26763).A+"",width:"721",height:"243"})}),"\n",(0,s.jsxs)(n.p,{children:["This page aims at providing a step-by-step guide for lift and shift migration of ",(0,s.jsx)(n.a,{href:"https://goharbor.io/",children:"Harbor"}),"\ncontainer registry, which operates in the Kubernetes environment and is deployed with Helm.\nThis migration scenario uses ",(0,s.jsx)(n.a,{href:"https://velero.io/",children:"Velero"})," tool which\nenables moving your Harbor instance as-is from one Kubernetes environment to another\nKubernetes environment. The motivation behind this could be e.g. migration\nfrom one cloud provider to another, an outdated Kubernetes environment of your Harbor\ninstance or avoiding the Harbor in-place upgrade."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that the official Harbor's documentation contains an \"",(0,s.jsx)(n.a,{href:"https://goharbor.io/docs/main/administration/upgrade/",children:"Upgrade Harbor and Migrate Data"}),'" page\nthat instructs users on how to upgrade and migrate Harbor data from one instance to\nanother. This tutorial supports only deployments that have been installed by ',(0,s.jsx)(n.a,{href:"https://goharbor.io/docs/main/install-config/download-installer/",children:"Harbor installer"})," script.\nHence, Harbor instances running in docker containers and spawned by docker-compose."]}),"\n",(0,s.jsxs)(n.p,{children:["Note that this guide is not limited to Harbor deployments that utilize SCS environments.\nVisit the ",(0,s.jsx)(n.a,{href:"#prerequisites",children:"prerequisites"})," section to see what is required for a successful\nmigration. These prerequisites come out of the box when the SCS infrastructure and KaaS\nare used for Harbor deployment, hence it is convenient to use them."]}),"\n",(0,s.jsx)(n.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(n.p,{children:["As this scenario uses a backup and restore procedure for the migration process, this section\nrefers to the prerequisites section in ",(0,s.jsx)(n.a,{href:"/docs/container/components/container-registry/docs/backup_and_restore#prerequisites",children:"Harbor - backup and restore"}),"\ndocs page."]}),"\n",(0,s.jsx)(n.h3,{id:"kubernetes-clusters",children:"Kubernetes clusters"}),"\n",(0,s.jsx)(n.p,{children:"This migration scenario expects that you want to migrate your Harbor instance\nbetween different Kubernetes clusters that could live in different environments (e.g.\nOpenStack projects) or even in different cloud providers. Let's call them Cluster_A and\nCluster_B. Cluster_A represents the Kubernetes cluster where your Harbor currently operates and\nCluster_B represents the target Kubernetes cluster to which you want to migrate your Harbor."}),"\n",(0,s.jsxs)(n.p,{children:["As Cluster_A and Cluster_B do not have to share the same infrastructure it is convenient to\nuse a full Harbor data backup (not a snapshot) using ",(0,s.jsx)(n.a,{href:"https://restic.net/",children:"Restic"}),"\nintegration in Velero. In this case, Cluster_A and Cluster_B should have\nKubernetes version ",(0,s.jsx)(n.strong,{children:"1.16"})," or greater.\nFor further details about Restic-Velero integration refer to the",(0,s.jsx)(n.br,{}),"\n","related ",(0,s.jsx)(n.a,{href:"https://velero.io/docs/main/file-system-backup/",children:"Velero docs"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Kubernetes versions of Cluster_A and Cluster_B may differ. In this case, it is\nnot unusual to see the Kubernetes API group versions differing between clusters. This\nincompatibility may cause issues during the migration of your Harbor instance. By default,\nVelero only backs up resources that use the preferred version of the Kubernetes API.\nHowever, Velero also includes a feature, ",(0,s.jsx)(n.a,{href:"https://velero.io/docs/main/enable-api-group-versions-feature/",children:"Enable API Group Versions"}),",\nthat overcomes this limitation and backup all Kubernetes API group versions that are\nsupported on the source Cluster_A. Then, if this feature is also enabled on the Cluster_B,\nVelero will make the best choice of Kubernetes API version which is defined in the group\nname of both source Cluster_A and target Cluster_B based on API group version priority order,\nread ",(0,s.jsx)(n.a,{href:"https://velero.io/docs/main/enable-api-group-versions-feature/",children:"docs"})," for further details.\nIf the above is the case consider installing Velero on both clusters\nwith a feature flag ",(0,s.jsx)(n.code,{children:"--features=EnableAPIGroupVersions"}),". Note that this feature is still in beta."]}),"\n",(0,s.jsx)(n.h3,{id:"s3-bucket-and-ec2-credentials",children:"S3 bucket and EC2 credentials"}),"\n",(0,s.jsxs)(n.p,{children:["This guide assumes that the public cloud's object store with S3-compatible API is available as\nthe storage backend for Velero. Refer to the ",(0,s.jsx)(n.a,{href:"/docs/container/components/container-registry/docs/backup_and_restore#s3-bucket-and-ec2-credentials",children:"S3 bucket and EC2 credentials"}),"\nsection in the backup and restore docs and create a bucket that will be later used for\nthe migration."]}),"\n",(0,s.jsx)(n.h3,{id:"velero-client",children:"Velero client"}),"\n",(0,s.jsxs)(n.p,{children:["Install the Velero client on your local environment, refer to ",(0,s.jsx)(n.a,{href:"/docs/container/components/container-registry/docs/backup_and_restore#velero-client",children:"Velero client"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"velero-server",children:"Velero server"}),"\n",(0,s.jsxs)(n.p,{children:["Install Velero server components along with the appropriate plugins, into the both\n(Cluster_A and Cluster_B) clusters. Keep in mind that we will use Restic uploader in\nVelero, hence follows interactions on how to do that in the related docs section ",(0,s.jsx)(n.a,{href:"/docs/container/components/container-registry/docs/backup_and_restore#velero-server",children:"Velero server"}),".\nDo not forget to add ",(0,s.jsx)(n.code,{children:"--kubeconfig"})," argument to install Velero server components\nto the Cluster_A and then to the Cluster_B. The rest of arguments should be the same:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:'velero install \\\n  --kubeconfig <path to the kubeconfig file of Cluster_[A,B]> \\ \n  --provider aws \\\n  --plugins velero/velero-plugin-for-aws:v1.6.1 \\\n  --bucket velero-backup \\\n  --secret-file ~/.aws/credentials \\\n  --use-volume-snapshots=false \\\n  --uploader-type=restic \\\n  --use-node-agent \\\n  --backup-location-config region=RegionOne,s3ForcePathStyle="true",s3Url=https://api.gx-scs.sovereignit.cloud:8080\n'})}),"\n",(0,s.jsxs)(n.p,{children:["It is a good practice to configure the backup location in the Cluster_B as read-only.\nThis will make sure that the backup created from Cluster_A is not deleted from the object\nstore by mistake during the restore to Cluster_B. To do this you can just edit the ",(0,s.jsx)(n.code,{children:"default"}),"\nBackupStorageLocation resource in Cluster_B."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"$ kubectl -n velero --kubeconfig <path of Cluster_B kubeconfig> edit backupstoragelocations default\n# Set the `accessMode` to `ReadOnly`\n# spec:\n#   accessMode: ReadOnly\n"})}),"\n",(0,s.jsx)(n.h2,{id:"migration-1",children:"Migration"}),"\n",(0,s.jsxs)(n.p,{children:["Before we start to migrate Harbor instance from one environment to another go through the\n",(0,s.jsx)(n.a,{href:"/docs/container/components/container-registry/docs/backup_and_restore#backup-and-restore",children:"Backup and restore"})," section and read\nvarious limitations of the backup/restore process to be aware of the potential impact on\nyour Harbor instance."]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Backup Harbor instance in Cluster_A","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://goharbor.io/docs/main/administration/backup-restore/#set-harbor-to-readonly",children:["Set Harbor to the ",(0,s.jsx)(n.code,{children:"ReadOnly"})," mode"]})}),"\n",(0,s.jsxs)(n.li,{children:["Exclude the volume of Redis in backup in Cluster_A","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# replace the namespace and pod name with yours\nkubectl -n default --kubeconfig <path of Cluster_A kubeconfig> annotate pod/harbor-harbor-redis-0 backup.velero.io/backup-volumes-excludes=data\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Back up Harbor in Cluster_A","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"velero backup create harbor-backup --kubeconfig <path of Cluster_A kubeconfig> --include-namespaces default --default-volumes-to-fs-backup --wait\n"})}),"\n","This creates a full backup of all resources in the given namespace including their\npersistent storages (besides Redis PV)."]}),"\n",(0,s.jsxs)(n.li,{children:["Optionally: ",(0,s.jsxs)(n.a,{href:"https://goharbor.io/docs/main/administration/backup-restore/#unset-readonly",children:["Unset Harbor from the ",(0,s.jsx)(n.code,{children:"ReadOnly"})," mode"]}),".\nKeep in mind that the ",(0,s.jsx)(n.code,{children:"ReadOnly"})," mode protects your Harbor instance from deleting\nrepository, artifact, tag, and pushing images. This ensures that the Harbor instance\nin Cluster_A will be in sync with the Harbor instance in Cluster_B after you restored\nHarbor instance from the backup in Cluster_B. Therefore, it is recommended to ",(0,s.jsx)(n.strong,{children:"not"}),"\nunset Harbor from the ",(0,s.jsx)(n.code,{children:"ReadOnly"})," mode in Cluster_A."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Restore Harbor instance in Cluster_B","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Restore from the Backup","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# replace the backup and restore names with yours\nvelero restore create harbor-restore --from-backup harbor-backup --kubeconfig <path of Cluster_B kubeconfig> --wait \n"})}),"\n","Velero backed up the whole namespace where the Harbor instance lives in Cluster_A,\ntherefore the restored namespace in Cluster_B may contain resources (e.g. service,\ningress, TLS certificates) that expose Harbor instance in the same way as in\nCluster_A. It is a good practice to test this Cluster_B instance before you allow\nusers to use it."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.a,{href:"https://goharbor.io/docs/main/administration/backup-restore/#unset-readonly",children:["Unset Harbor from the ",(0,s.jsx)(n.code,{children:"ReadOnly"})," mode"]}),".\nAs we set Harbor in Cluster_A to ReadOnly when doing the backup, the instance is\nstill in ReadOnly mode after restoring. Unset Harbor from the ReadOnly mode after\nyou check its functionality."]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},26763:(e,n,r)=>{r.d(n,{A:()=>t});const t=r.p+"assets/images/harbor_migration-15d83bf7e5b37c0bdcb698280dde0684.png"},28453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>a});var t=r(96540);const s={},o=t.createContext(s);function i(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);