"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[63811],{78356:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"scs-0219-v1-kaas-networking","title":"KaaS Networking Standard","description":"Introduction","source":"@site/standards/scs-0219-v1-kaas-networking.md","sourceDirName":".","slug":"/scs-0219-v1-kaas-networking","permalink":"/standards/scs-0219-v1-kaas-networking","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"KaaS Networking Standard","type":"Standard","status":"Stable","stabilized_at":"2024-11-21T00:00:00.000Z","track":"KaaS"},"sidebar":"standards","previous":{"title":"scs-0219: KaaS Networking Standard","permalink":"/standards/kaas/scs-0219"},"next":{"title":"W1","permalink":"/standards/scs-0219-w1-kaas-networking"}}');var s=t(74848),r=t(28453);const o={title:"KaaS Networking Standard",type:"Standard",status:"Stable",stabilized_at:new Date("2024-11-21T00:00:00.000Z"),track:"KaaS"},a=void 0,c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Terminology",id:"terminology",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Design Considerations",id:"design-considerations",level:2},{value:"Options considered",id:"options-considered",level:3},{value:"NetworkPolicy API",id:"networkpolicy-api",level:4},{value:"Default Network Policies in Namespaces",id:"default-network-policies-in-namespaces",level:4},{value:"AdminNetworkPolicy API",id:"adminnetworkpolicy-api",level:4},{value:"Ingress API",id:"ingress-api",level:4},{value:"Decision",id:"decision",level:2},{value:"Conformance Tests",id:"conformance-tests",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"Kubernetes defines a networking model that needs to be implemented by a separate CNI plugin.\nBeyond basic connectivity within the cluster, however, there are many networking features that are specified but optional.\nSome of these optional features provide vital functionality, such as the NetworkPolicy API and the Ingress API."}),"\n",(0,s.jsx)(n.p,{children:"This standard specifies a minimal set of networking features that users can expect in clusters created by an SCS-compliant KaaS provider."}),"\n",(0,s.jsx)(n.h2,{id:"terminology",children:"Terminology"}),"\n",(0,s.jsx)(n.p,{children:"The following terms are used throughout this document:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Term"}),(0,s.jsx)(n.th,{children:"Meaning"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"KaaS, managed Kubernetes"}),(0,s.jsx)(n.td,{children:"Kubernetes as a Service, automated on-demand deployment of Kubernetes clusters."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"CSP"}),(0,s.jsx)(n.td,{children:"Cloud Service Provider, the provider of the KaaS infrastructure."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"CNI"}),(0,s.jsx)(n.td,{children:"Container Network Interface, a standardized networking interface for container runtimes."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"CNI plugin, networking plugin"}),(0,s.jsx)(n.td,{children:"Kubernetes bindings for a CNI implementation, translates Kubernetes API concepts into more basic container networking concepts."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"network policy"}),(0,s.jsx)(n.td,{children:"A set of rules to restrict network traffic in a Kubernetes cluster."})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,s.jsx)(n.p,{children:"KaaS providers will typically support aditional networking functionality beyond basic Kubernetes networking.\nThe specific range of features depends on the used CNI plugin, but may also be extended by additional operators.\nUsers may expect certain optional functionality, so we should define a baseline feature set that has to be available in an SCS-compliant KaaS cluster."}),"\n",(0,s.jsx)(n.h2,{id:"design-considerations",children:"Design Considerations"}),"\n",(0,s.jsxs)(n.p,{children:["The Kubernetes API can be extended arbitrarily.\nMany CNI plugins will define custom resources to enable functionality that is not covered in the official ",(0,s.jsx)(n.a,{href:"https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.31/",children:"API specification"}),".\nSometimes they will even reuse names from different API groups, such as ",(0,s.jsx)(n.code,{children:"NetworkPolicy"}),", which exists in the basic ",(0,s.jsx)(n.code,{children:"networking.k8s.io/v1"})," API, but also in ",(0,s.jsx)(n.code,{children:"projectcalico.org/v3"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"To avoid any ambiguity, we should therefore be explicit about the API groups and versions of resources.\nWe should also avoid mandating third-party API extensions, to avoid dependencies on specific third-party software and keep the standard as generic as possible."}),"\n",(0,s.jsx)(n.h3,{id:"options-considered",children:"Options considered"}),"\n",(0,s.jsx)(n.h4,{id:"networkpolicy-api",children:"NetworkPolicy API"}),"\n",(0,s.jsx)(n.p,{children:"Kubernetes network policies are used to restrict network traffic between pods in a cluster, but also between pods and external network resources.\nThe policy rules can filter based on port and address ranges, but also on Kubernetes-specific target attributes such as namespaces and labels.\nThey must be implemented by the CNI plugin, and though they are widely supported, they are still technically optional, and there are some lightweight networking plugins, such as Flannel, that are not enforcing them."}),"\n",(0,s.jsx)(n.p,{children:"Nonetheless, network policies are widely used and most users will expect them in a managed Kubernetes cluster.\nThe wide, but varying support among CNI plugins makes them a good target for SCS standardization."}),"\n",(0,s.jsx)(n.h4,{id:"default-network-policies-in-namespaces",children:"Default Network Policies in Namespaces"}),"\n",(0,s.jsx)(n.p,{children:"Basic network policies are namespaced resources, and can only filter traffic to and from pods in their own namespace.\nIn a newly created namespace without policies the default behavior will apply, which is to not restrict traffic at all."}),"\n",(0,s.jsx)(n.p,{children:"It can be desirable to automatically create default network policies in new namespaces, using a policy operator such as Kyverno.\nA CSP could provide such an operator and offer a number of default policies, like blocking connections to other namespaces by default, or blocking access to the OpenStack metadata service."}),"\n",(0,s.jsx)(n.p,{children:"Any user with permissions to manage their own network policies in a namespace will of course be able to remove or modify any default network policies in that namespace.\nCSP-provided network policies should thus only be viewed as a safety default, and should only be deployed if they are actually beneficial to users."}),"\n",(0,s.jsx)(n.h4,{id:"adminnetworkpolicy-api",children:"AdminNetworkPolicy API"}),"\n",(0,s.jsxs)(n.p,{children:["An alternative to automatically created default network policies are API extensions that allow cluster-wide networking rules.\nSome CNI plugins have implemented such extensions, e.g. Calico's ",(0,s.jsx)(n.code,{children:"GlobalNetworkPolicy"})," and Cilium's ",(0,s.jsx)(n.code,{children:"CiliumClusterwideNetworkPolicy"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The Kubernetes Network Special Interest Group is currently working on an ",(0,s.jsx)(n.a,{href:"https://network-policy-api.sigs.k8s.io/api-overview/",children:"official API extension"})," to cover this functionality.\nThis API extension introduces the new ",(0,s.jsx)(n.code,{children:"AdminNetworkPolicy"})," and ",(0,s.jsx)(n.code,{children:"BaselineAdminNetworkPolicy"})," resources, which represent cluster-wide network policies with respectively higher or lower precedence than namespaced network policies."]}),"\n",(0,s.jsx)(n.p,{children:"This API is also a good candidate for standardization because it consolidates a number of vendor-specific workarounds to limitations of the NetworkPolicy API.\nIt has not been stabilized yet, so currently we can at most recommend CNI plugins where there is ongoing work to support these features."}),"\n",(0,s.jsx)(n.h4,{id:"ingress-api",children:"Ingress API"}),"\n",(0,s.jsxs)(n.p,{children:["The Ingress API allows the external exposure of HTTP/HTTPS-based services running in the cluster.\nUnlike the L3/L4-based LoadBalancer Service type, Ingress provides L7 load balancing, HTTP routing, and TLS termination for services.\nThis functionality can be provided within the cluster by a pod-based ingress controller such as ",(0,s.jsx)(n.code,{children:"ingress-nginx"}),", that exposes Ingress resources as Services."]}),"\n",(0,s.jsx)(n.p,{children:"However, there are also Ingress controllers that integrate with underlying infrastructure and may help to reduce overhead.\nExamples for this are the Cilium CNI plugin, which comes with built-in Ingress support, and the Octavia Ingress controller, which may be a good choice if OpenStack Octavia is already used to provide L3/L4 load balancing."}),"\n",(0,s.jsxs)(n.p,{children:["The CSPs that manage the underlying infrastructure can of course make the best choice for such an integrated Ingress controller, so they should be encouraged to do so.\nEven with a CSP-provided default Ingress controller present, users will be able to use alternative Ingress controllers by creating a new ",(0,s.jsx)(n.code,{children:"IngressClass"}),", which can then be referenced in Ingress resources."]}),"\n",(0,s.jsx)(n.h2,{id:"decision",children:"Decision"}),"\n",(0,s.jsxs)(n.p,{children:["CSPs MUST provide a network plugin that fully supports ",(0,s.jsx)(n.code,{children:"NetworkPolicy"})," resources in the API version ",(0,s.jsx)(n.code,{children:"networking.k8s.io/v1"}),".\nCSPs SHOULD provide a network plugin that supports or is working on support for the ",(0,s.jsx)(n.code,{children:"AdminNetworkPolicy"})," and ",(0,s.jsx)(n.code,{children:"BaselineAdminNetworkPolicy"})," resources of the ",(0,s.jsx)(n.code,{children:"policy.networking.k8s.io"})," API group, in their latest version, up to ",(0,s.jsx)(n.code,{children:"v1"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["CSPs SHOULD offer the option for a managed, ",(0,s.jsx)(n.code,{children:"networking.k8s.io/v1"}),"-compliant Ingress controller and a default ",(0,s.jsx)(n.code,{children:"IngressClass"})," resource for this controller."]}),"\n",(0,s.jsxs)(n.p,{children:["CSPs MAY add default networking restrictions, using either ",(0,s.jsx)(n.code,{children:"networking.k8s.io/v1"}),"-compliant ",(0,s.jsx)(n.code,{children:"NetworkPolicy"})," resources with a policy operator, or alternatively any cluster-wide network policy extensions provided by the CNI plugin."]}),"\n",(0,s.jsx)(n.h2,{id:"conformance-tests",children:"Conformance Tests"}),"\n",(0,s.jsx)(n.p,{children:"Required support for network policies will be tested using the upstream e2e tests via Sonobuoy."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(96540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);