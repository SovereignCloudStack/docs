"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[30458],{62845:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"scs-0211-v1-kaas-default-storage-class","title":"SCS KaaS default storage class","description":"The SCS-0211 standard outlines the properties required for the default StorageClass in Kubernetes as a Service (KaaS).\\nThe standard ensures that the default StorageClass, identified by the \\"storageclass.kubernetes.io/is-default-class\\"\\nannotation, supports the ReadWriteOnce access mode and protects volume data against loss due to single disk or\\nhost hardware failures.\\n","source":"@site/standards/scs-0211-v1-kaas-default-storage-class.md","sourceDirName":".","slug":"/scs-0211-v1-kaas-default-storage-class","permalink":"/standards/scs-0211-v1-kaas-default-storage-class","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"SCS KaaS default storage class","type":"Standard","status":"Stable","stabilized_at":"2023-02-13T00:00:00.000Z","track":"KaaS","description":"The SCS-0211 standard outlines the properties required for the default StorageClass in Kubernetes as a Service (KaaS).\\nThe standard ensures that the default StorageClass, identified by the \\"storageclass.kubernetes.io/is-default-class\\"\\nannotation, supports the ReadWriteOnce access mode and protects volume data against loss due to single disk or\\nhost hardware failures.\\n"},"sidebar":"standards","previous":{"title":"scs-0211: SCS KaaS default storage class","permalink":"/standards/kaas/scs-0211"},"next":{"title":"V2","permalink":"/standards/scs-0211-v2-kaas-default-storage-class"}}');var n=t(74848),r=t(28453);const o={title:"SCS KaaS default storage class",type:"Standard",status:"Stable",stabilized_at:new Date("2023-02-13T00:00:00.000Z"),track:"KaaS",description:'The SCS-0211 standard outlines the properties required for the default StorageClass in Kubernetes as a Service (KaaS).\nThe standard ensures that the default StorageClass, identified by the "storageclass.kubernetes.io/is-default-class"\nannotation, supports the ReadWriteOnce access mode and protects volume data against loss due to single disk or\nhost hardware failures.\n'},i=void 0,d={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Decision",id:"decision",level:2},{value:"Required non-performance-related properties",id:"required-non-performance-related-properties",level:3},{value:"Required performance-related properties",id:"required-performance-related-properties",level:3},{value:"Related Documents",id:"related-documents",level:2},{value:"Conformance Tests",id:"conformance-tests",level:2}];function c(e){const s={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.h2,{id:"introduction",children:"Introduction"}),"\n",(0,n.jsxs)(s.p,{children:["Cluster consumers can request persistent storage via ",(0,n.jsx)(s.a,{href:"https://kubernetes.io/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims",children:(0,n.jsx)(s.code,{children:"PersistentVolumeClaims"})})," which is provisioned automatically by cloud-provided automation.\nStorage requirements may vary across use cases, so there is the concept of ",(0,n.jsx)(s.code,{children:"StorageClasses"}),". ",(0,n.jsx)(s.code,{children:"StorageClasses"})," define some set of storage properties. So, consumers can choose one of these depending on the use case."]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.a,{href:"https://kubernetes.io/docs/concepts/storage/persistent-volumes/",children:"Kubernetes documentation"})}),"\n",(0,n.jsx)(s.h2,{id:"motivation",children:"Motivation"}),"\n",(0,n.jsxs)(s.p,{children:["While often times, consumers will choose a ",(0,n.jsx)(s.code,{children:"StorageClass"})," explicitly, usually, there is also a default ",(0,n.jsx)(s.code,{children:"StorageClass"})," to fall back on in case it is ",(0,n.jsx)(s.em,{children:"not"})," chosen explicitly (that is, when ",(0,n.jsx)(s.code,{children:"storageClassName"})," is not set on the ",(0,n.jsx)(s.code,{children:"PersistentVolumeClaim"}),")."]}),"\n",(0,n.jsxs)(s.p,{children:["This document attempts to define the properties this default ",(0,n.jsx)(s.code,{children:"StorageClass"})," should have."]}),"\n",(0,n.jsx)(s.h2,{id:"decision",children:"Decision"}),"\n",(0,n.jsxs)(s.p,{children:["The default ",(0,n.jsx)(s.code,{children:"StorageClass"})," is made default using the ",(0,n.jsx)(s.code,{children:"storageclass.kubernetes.io/is-default-class"})," annotation, following ",(0,n.jsx)(s.a,{href:"https://kubernetes.io/docs/tasks/administer-cluster/change-default-storage-class/",children:"Kubernetes upstream"}),". Hence, standardizing its name is not required for the intents of this standard."]}),"\n",(0,n.jsx)(s.h3,{id:"required-non-performance-related-properties",children:"Required non-performance-related properties"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.code,{children:"ReadWriteOnce"})," must be a supported ",(0,n.jsx)(s.a,{href:"https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes",children:"access mode"})]}),"\n",(0,n.jsx)(s.li,{children:"volume must be protected against data loss due to hardware failures of a single disk or host"}),"\n",(0,n.jsx)(s.li,{children:"volume must not be bound to the lifecycle of a Kubernetes Node"}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"Hence,"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"...volume must not be backed by local storage on the Kubernetes Node VM itself"}),"\n",(0,n.jsx)(s.li,{children:"...volume may be backed by some kind of redundant storage within an AZ, across hosts"}),"\n",(0,n.jsx)(s.li,{children:"...volume may be backed by some kind of redundant storage across AZ's"}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"required-performance-related-properties",children:"Required performance-related properties"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.em,{children:"NO"})," fixed guarantees regarding latency/bandwidth/IOPS/..."]}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"Generally, customers should be able to expect low-tier performance without pricing surprises."}),"\n",(0,n.jsx)(s.h2,{id:"related-documents",children:"Related Documents"}),"\n",(0,n.jsx)(s.p,{children:"This document does not describe performance related properties.\nThis will be done in another document which is yet to be created."}),"\n",(0,n.jsx)(s.h2,{id:"conformance-tests",children:"Conformance Tests"}),"\n",(0,n.jsxs)(s.p,{children:["The script ",(0,n.jsx)(s.code,{children:"k8s-default-storage-class-check.py"})," requires a kubeconfig file with connection\ndetails for the Kubernetes cluster that should be checked for conformance.\nIt will check for a default storage class and use the associated storage provider to\ntry to create and mount a PersistentVolumeClaim with the aforementioned properties to\na container in a Pod.\nAfter it is done, it cleans up the resources.\nRule violations will be reported on various logging channels: ERROR for mandatory rules\nand INFO for recommended rules.\nAn exit code of zero indicates that the standard has been met."]})]})}function u(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},28453:(e,s,t)=>{t.d(s,{R:()=>o,x:()=>i});var a=t(96540);const n={},r=a.createContext(n);function o(e){const s=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),a.createElement(r.Provider,{value:s},e.children)}}}]);