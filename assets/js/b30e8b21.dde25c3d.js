"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[96578],{76807:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"scs-0217-v1-cluster-hardening","title":"Kubernetes cluster hardening","description":"Introduction","source":"@site/standards/scs-0217-v1-cluster-hardening.md","sourceDirName":".","slug":"/scs-0217-v1-cluster-hardening","permalink":"/standards/scs-0217-v1-cluster-hardening","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Kubernetes cluster hardening","type":"Standard","status":"Draft","track":"KaaS"},"sidebar":"standards","previous":{"title":"scs-0217: Kubernetes cluster hardening","permalink":"/standards/kaas/scs-0217"},"next":{"title":"scs-0218: Container registry for SCS standard implementation","permalink":"/standards/kaas/scs-0218"}}');var i=n(74848),r=n(28453);const o={title:"Kubernetes cluster hardening",type:"Standard",status:"Draft",track:"KaaS"},a=void 0,c={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Terminology",id:"terminology",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Hardening Kubernetes",id:"hardening-kubernetes",level:2},{value:"Regular updates",id:"regular-updates",level:3},{value:"Securing etcd",id:"securing-etcd",level:3},{value:"Strong authentication",id:"strong-authentication",level:4},{value:"Multiple etcd instances",id:"multiple-etcd-instances",level:4},{value:"etcd isolation",id:"etcd-isolation",level:4},{value:"ACL restrictions",id:"acl-restrictions",level:4},{value:"TLS communication",id:"tls-communication",level:4},{value:"Securing endpoints",id:"securing-endpoints",level:3},{value:"Control plane nodes",id:"control-plane-nodes",level:4},{value:"Worker nodes",id:"worker-nodes",level:4},{value:"API security, authentication and authorization",id:"api-security-authentication-and-authorization",level:3},{value:"Authentication",id:"authentication",level:4},{value:"Authorization",id:"authorization",level:4},{value:"Admission Controllers",id:"admission-controllers",level:4},{value:"Kubelet access control",id:"kubelet-access-control",level:3},{value:"Pod security policies",id:"pod-security-policies",level:3},{value:"Further measurements",id:"further-measurements",level:3},{value:"Standard",id:"standard",level:2},{value:"Conformance Tests",id:"conformance-tests",level:2},{value:"Related Documents",id:"related-documents",level:2}];function l(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsx)(t.p,{children:"Due to the regular changes and updates, there are always new security features to deploy and use in Kubernetes.\nNevertheless, a provider (or even a customer) needs to take action in order to achieve a\nbaseline-secure cluster due to the myriad of configurations possible. This is especially\nthe case since Kubernetes ships with insecure features and configurations out of the box,\nwhich will need to be mitigated by an administrator with the proper knowledge.\nSecure Kubernetes clusters are desirable regardless of the possible threat model,\nsince higher security doesn't necessarily mean higher complexity in this case."}),"\n",(0,i.jsx)(t.h2,{id:"terminology",children:"Terminology"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Term"}),(0,i.jsx)(t.th,{children:"Meaning"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"TLS"}),(0,i.jsx)(t.td,{children:"Transport Layer Security"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"CA"}),(0,i.jsx)(t.td,{children:"Certificate Authority"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"JWT"}),(0,i.jsx)(t.td,{children:"JSON Web Token"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"ABAC"}),(0,i.jsx)(t.td,{children:"Attribute-based access control"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"RBAC"}),(0,i.jsx)(t.td,{children:"Role-based access control"})]})]})]}),"\n",(0,i.jsx)(t.h2,{id:"motivation",children:"Motivation"}),"\n",(0,i.jsx)(t.p,{children:"Kubernetes clusters are highly configurable, which also gives rise to different security\nproblems, if the configuration isn't done properly.\nThese security risks can potentially be exposed in many different parts of a cluster, e.g.\ndifferent APIs, authorization and authentication procedures or even Pod privilege mechanisms.\nIn order to mitigate these problems, different steps and hardening mechanisms could be used\nto increase the security of a Kubernetes setup.\nDue to the focus of the SCS KaaS standards on the providers, best practices for security\nthat are more focused on user environments aren't described here, e.g., the possibility for\nnetwork traffic control between pods. This could theoretically be set up by a provider,\nbut isn't very practical for the user, since he would probably need to request changes\nregularly in this case."}),"\n",(0,i.jsx)(t.h2,{id:"hardening-kubernetes",children:"Hardening Kubernetes"}),"\n",(0,i.jsx)(t.p,{children:"This section is non-authoritative and only describes concepts and design considerations."}),"\n",(0,i.jsx)(t.h3,{id:"regular-updates",children:"Regular updates"}),"\n",(0,i.jsxs)(t.p,{children:["Due to the risk associated with running older versions of software, e.g. known security vulnerabilities,\nbugs or missing features as well as the difficulty of tracking or identifying attack vectors,\nit is advised to first and foremost keep the version of the Kubernetes components up-to-date.\nIt should be especially important to keep on track with the patch-level ",(0,i.jsx)(t.a,{href:"https://kubernetes.io/releases/",children:"versions of Kubernetes"}),",\nsince they include bugfixes and security patches, which are also backported to the previous\nthree minor-level versions, depending on their severity and the feasibility. It is also recommended\nto refer to the version skew policy for more details about ",(0,i.jsx)(t.a,{href:"https://kubernetes.io/releases/version-skew-policy/",children:"component versions"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"securing-etcd",children:"Securing etcd"}),"\n",(0,i.jsx)(t.p,{children:"The etcd database is the storage for Kubernetes, containing information about cluster workloads, states and secrets.\nGaining access to this critical infrastructure part would enable a bad actor to read the aforementioned information;\nwrite access would be equivalent to administrative access on the Kubernetes cluster and information could be manipulated\nwhile ignoring any restrictions or validations put in place by other Kubernetes components."}),"\n",(0,i.jsx)(t.p,{children:"Securing etcd can be done through different or a combination of\nmany mechanisms, including strong security credentials for the etcd server, the isolation of the etcd servers behind a firewall, separate etcd\ninstances for components beside the API-server, ACL restrictions for read-write-access to subsets of the keyspace and\na separate CA for etcd communication, which limits the trusted partners of the etcd database to clients with a certificate from this CA.\nThese strategies will be explained a bit more in-depth in the following subsections."}),"\n",(0,i.jsx)(t.h4,{id:"strong-authentication",children:"Strong authentication"}),"\n",(0,i.jsxs)(t.p,{children:["If an etcd instance wasn't secured correctly, it could be possible that a bad actor would try to authenticate against\nthe database.\nIt is therefore advised to use strong security credentials (see e.g. ",(0,i.jsx)(t.a,{href:"https://pages.nist.gov/800-63-3/sp800-63b.html",children:"the strong credentials requirements by NIST"}),") for\nall user accounts on the etcd server as well as the machines running this critical component.\nThis is obviously a fact for all possibly accessible components, but especially true for etcd, since it contains\nthe complete cluster state."]}),"\n",(0,i.jsx)(t.h4,{id:"multiple-etcd-instances",children:"Multiple etcd instances"}),"\n",(0,i.jsxs)(t.p,{children:["etcd is a critical component that needs to be protected from\nbad actors as well as outages. Kubernetes recommends a ",(0,i.jsx)(t.a,{href:"https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/#multi-node-etcd-cluster",children:"five-member cluster"})," for durability and high-availability as well as regular back-ups of the data.\nFor more information on high-availability, look into the ",(0,i.jsx)(t.a,{href:"/standards/scs-0214-v1-k8s-node-distribution",children:"Kubernetes Node Distribution and Availability Standard"}),".\nIt would also be possible to use these etcd instances in order to select specific instances\nthat aren't the current etcd leader for interaction with different components (e.g. Calico), since access to the primary etcd instance could be considered dangerous, because the full keyspace could be viewed without further restrictions (see ",(0,i.jsx)(t.a,{href:"https://cheatsheetseries.owasp.org/cheatsheets/Kubernetes_Security_Cheat_Sheet.html#limiting-access-to-the-primary-etcd-instance",children:"here"})," or ",(0,i.jsx)(t.a,{href:"https://docs.tigera.io/calico/latest/reference/etcd-rbac/kubernetes-advanced",children:"here"}),").\nThis approach should still be paired with ",(0,i.jsx)(t.a,{href:"#acl-restrictions",children:"etcd ACL"})," to better restrict access."]}),"\n",(0,i.jsx)(t.h4,{id:"etcd-isolation",children:"etcd isolation"}),"\n",(0,i.jsx)(t.p,{children:"The etcd database should at best be isolated from the rest of a Kubernetes cluster.\nAccess should only be granted to components that need it, which is in most cases mainly (or only)\nthe API server. Best practice would be to host etcd on machines separate from the Kubernetes cluster\nand block access from machines or networks that don't need access with specific firewall rules.\nIn most cases, only the API server machines should need access to etcd on ports 2379-2380."}),"\n",(0,i.jsx)(t.h4,{id:"acl-restrictions",children:"ACL restrictions"}),"\n",(0,i.jsxs)(t.p,{children:["etcd implements access control lists (ACL) and authentication since version 2.1 ",(0,i.jsx)(t.a,{href:"https://etcd.io/docs/v3.3/op-guide/authentication/",children:"1"}),".\netcd provides users and roles; users gain permissions through roles. When authentication is enabled,\neach request to etcd requires authentication and the transaction is only allowed, if the user has the correct access rights.\netcd can also be launched with ",(0,i.jsx)(t.code,{children:"--client-cert-auth=true"}),", which enables authentication via\nthe Common Name (CN) field of a client TLS certificate without a password.\nThis option enables Kubernetes components to authenticate as a user without providing a password,\nwhich is neither possible for Kubernetes components nor planned in future releases.\nThis method is recommended in order to implement ACL for different Kubernetes components and\nnot give the Kubernetes API full root access to the etcd instance; instead, a separate user can be created."]}),"\n",(0,i.jsx)(t.h4,{id:"tls-communication",children:"TLS communication"}),"\n",(0,i.jsxs)(t.p,{children:["etcd should use TLS for peer- and cluster-communication, so that traffic between different peered etcd instances as well\nas the communication with the Kubernetes cluster can be secured.\netcd provides options for all these scenarios, including ",(0,i.jsx)(t.code,{children:"--peer-key-file=peer.key"})," and ",(0,i.jsx)(t.code,{children:"--peer-cert-file=peer.cert"}),"\nfor securing peer communication and the flags ",(0,i.jsx)(t.code,{children:"--key-file=k8sclient.key"})," and ",(0,i.jsx)(t.code,{children:"--cert-file=k8sclient.cert"})," for securing\nclient communication (and therefore cluster communication).\nAdditionally, HTTPS should be used as the URL schema.\nIt is also possible to use a separate CA for the etcd in order to separate and better control access through client\ncertificates, since etcd by default trusts all the certificates issued by the root CA ",(0,i.jsx)(t.a,{href:"https://kubernetes.io/blog/2021/10/05/nsa-cisa-kubernetes-hardening-guidance/",children:"2"}),".\nMore information about authentication via TLS is provided in the chapter ",(0,i.jsx)(t.a,{href:"#acl-restrictions",children:"ACL restrictions"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"securing-endpoints",children:"Securing endpoints"}),"\n",(0,i.jsx)(t.p,{children:"Kubernetes provides a well-defined set of ports in its default configuration. These ports are\nused for inter-component communication as well as external access. Due to the distribution of information\nabout Kubernetes clusters, it is easy for a bad actor to identify a clusters\nports and try to attack them. In order to minimize the attack vector, internal ports (and therefore components)\nshould not be accessible from external networks, except if there are requirements to enable this behavior."}),"\n",(0,i.jsx)(t.p,{children:"A good way to restrict access would be a combination of firewalls with port\nblocking and the integration of network separation.\nHow this is done is highly dependent on the specific setup of the provider.\nAn additional document could be provided in the future to give basic\nguidelines for this task."}),"\n",(0,i.jsx)(t.p,{children:"A list of the default ports used in Kubernetes as well as the components accessing them can be found below:"}),"\n",(0,i.jsx)(t.h4,{id:"control-plane-nodes",children:"Control plane nodes"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Ports"}),(0,i.jsx)(t.th,{children:"Protocol"}),(0,i.jsx)(t.th,{children:"Purpose"}),(0,i.jsx)(t.th,{children:"Used by"}),(0,i.jsx)(t.th,{children:"Access type"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"6443"}),(0,i.jsx)(t.td,{children:"TCP"}),(0,i.jsx)(t.td,{children:"API server"}),(0,i.jsx)(t.td,{children:"All"}),(0,i.jsx)(t.td,{children:"External, internal"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"2379-2380"}),(0,i.jsx)(t.td,{children:"TCP"}),(0,i.jsx)(t.td,{children:"etcd server"}),(0,i.jsx)(t.td,{children:"kube-apiserver, etcd"}),(0,i.jsx)(t.td,{children:"Internal"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"10250"}),(0,i.jsx)(t.td,{children:"TCP"}),(0,i.jsx)(t.td,{children:"Kubelet API"}),(0,i.jsx)(t.td,{children:"Self, Control plane"}),(0,i.jsx)(t.td,{children:"Internal"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"10255"}),(0,i.jsx)(t.td,{children:"TCP"}),(0,i.jsx)(t.td,{children:"Read-only Kubelet API"}),(0,i.jsx)(t.td,{children:"External applications"}),(0,i.jsx)(t.td,{children:"External, Internal"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"10257"}),(0,i.jsx)(t.td,{children:"TCP"}),(0,i.jsx)(t.td,{children:"kube-controller-manager"}),(0,i.jsx)(t.td,{children:"Self"}),(0,i.jsx)(t.td,{children:"Internal"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"10259"}),(0,i.jsx)(t.td,{children:"TCP"}),(0,i.jsx)(t.td,{children:"kube-scheduler"}),(0,i.jsx)(t.td,{children:"Self"}),(0,i.jsx)(t.td,{children:"Internal"})]})]})]}),"\n",(0,i.jsxs)(t.p,{children:["Hint: ",(0,i.jsx)(t.code,{children:"Self"})," in the ",(0,i.jsx)(t.code,{children:"Used by"})," context means, that a resource will access its own port for requests."]}),"\n",(0,i.jsx)(t.h4,{id:"worker-nodes",children:"Worker nodes"}),"\n",(0,i.jsxs)(t.table,{children:[(0,i.jsx)(t.thead,{children:(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.th,{children:"Ports"}),(0,i.jsx)(t.th,{children:"Protocol"}),(0,i.jsx)(t.th,{children:"Purpose"}),(0,i.jsx)(t.th,{children:"Used by"}),(0,i.jsx)(t.th,{children:"Access type"})]})}),(0,i.jsxs)(t.tbody,{children:[(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"10250"}),(0,i.jsx)(t.td,{children:"TCP"}),(0,i.jsx)(t.td,{children:"Kubelet API"}),(0,i.jsx)(t.td,{children:"Self, Control plane"}),(0,i.jsx)(t.td,{children:"Internal"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"10255"}),(0,i.jsx)(t.td,{children:"TCP"}),(0,i.jsx)(t.td,{children:"Read-only Kubelet API"}),(0,i.jsx)(t.td,{children:"External applications"}),(0,i.jsx)(t.td,{children:"External, internal"})]}),(0,i.jsxs)(t.tr,{children:[(0,i.jsx)(t.td,{children:"30000-32767"}),(0,i.jsx)(t.td,{children:"TCP"}),(0,i.jsx)(t.td,{children:"NodePort Services"}),(0,i.jsx)(t.td,{}),(0,i.jsx)(t.td,{children:"External"})]})]})]}),"\n",(0,i.jsx)(t.h3,{id:"api-security-authentication-and-authorization",children:"API security, authentication and authorization"}),"\n",(0,i.jsx)(t.p,{children:"In order to secure Kubernetes against bad actors, limiting and securing access to API requests\nis recommended, since requests to those are able to control the entire Kubernetes cluster.\nAccess control is applied to both human users and Kubernetes service accounts, which goes through\nseveral stages after a request reaches the API."}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["The Kubernetes API server listens on port 6443 on the first non-localhost network interface by default,\nprotected by TLS ",(0,i.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/security/controlling-access/",children:"3"}),". The TLS certificate can either be signed with a private CA or based on a public key\ninfrastructure with a widely recognized CA behind it."]}),"\n",(0,i.jsx)(t.li,{children:"The authentication step checks the request for correct authentication based on different possible\nauthentication modules like password, plain tokens or JWT. Only one of these methods needs to succeed\nin order to allow a request to pass to the next stage."}),"\n",(0,i.jsx)(t.li,{children:"The authorization step authorizes a request, if a user is allowed to carry out a specific operation.\nThe request must contain the username of the requester, the requested action and the affected object.\nKubernetes supports different authorization modules like ABAC, RBAC or Webhooks. Only one of these\nmodules need to approve the request in order for it to be authorized."}),"\n",(0,i.jsx)(t.li,{children:"The last step are Admission control modules, which can modify or reject requests after accessing\nthe objects contents."}),"\n"]}),"\n",(0,i.jsx)(t.h4,{id:"authentication",children:"Authentication"}),"\n",(0,i.jsxs)(t.p,{children:["Kubernetes provides different internal authentication mechanisms, that can be used depending\non the requirements of the cluster provider and user. Multiple authentication systems can\nbe enabled and the ",(0,i.jsx)(t.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/authentication/",children:"Kubernetes documentation"})," recommends at least using two methods,\nincluding Service Account Tokens and another method. Methods directly provided by Kubernetes include\nthe following (a more complete or up-to-date list may be found in the ",(0,i.jsx)(t.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/authentication/",children:"Kubernetes authentication docs"}),"):"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.em,{children:"Static Token Files"})}),"\n",(0,i.jsxs)(t.p,{children:["This method reads bearer tokens from requests and checks them against a CSV file provided to Kubernetes containing\nthree columns named ",(0,i.jsx)(t.code,{children:"token"}),", ",(0,i.jsx)(t.code,{children:"username"})," and ",(0,i.jsx)(t.code,{children:"uid"}),". These tokens last indefinitely and the list can't be changed\nwithout a restart of the API server. This makes this option unsuitable for production clusters."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.em,{children:"Service Account Tokens"})}),"\n",(0,i.jsxs)(t.p,{children:["A service account is an authenticator that uses signed bearer tokens for request verification.\nService accounts can be given to the API server with a file containing PEM-encoded X509 RSA or\nECDSA private or public keys that verify the Service Account Tokens.\nService Accounts are normally created automatically by the API server and associated with the\npods through the ",(0,i.jsx)(t.code,{children:"ServiceAccount"})," admission controller. Tokens are signed JSON Web Tokens,\nthat can be used as a Bearer Token or mounted into the pods for API server access.\nSince Service Account Tokens are mainly used to allow workloads accessing the API server,\nthey're not really intended to authenticate users in production clusters."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.em,{children:"X509 client certificates"})}),"\n",(0,i.jsxs)(t.p,{children:["Client certificate authentication can be enabled by providing a ",(0,i.jsx)(t.code,{children:"Certificate Authority"}),"\nfile to the API server via the ",(0,i.jsx)(t.code,{children:"--client-ca-file="})," option. The file contains one\nor more CAs that a presented client certificate is validated against.\nIn this case the common subject name is used as the username for the request;\nadditionally, a group membership can be indicated with the certificates organization field.\nThese certificates are unsuitable for production use, because Kubernetes does not\nsupport certificate revocation. This means user credentials can't be modified or\nrevoked without rotating the root CA and re-issuing all cluster certificates."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"As outlined, most internal authentication mechanisms of Kubernetes aren't really\nusable in productive environments at the current time. Instead, external authentication\nshould be used in order to provide production-ready workflows.\nThe Kubernetes documentation lists a few examples for external authenticators, e.g."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens",children:"OpenIDConnect"})}),"\n",(0,i.jsxs)(t.li,{children:["Bearer Tokens with ",(0,i.jsx)(t.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/authentication/#webhook-token-authentication",children:"Webhook Token Authentication"})]}),"\n",(0,i.jsxs)(t.li,{children:["Request Header Authentication with an ",(0,i.jsx)(t.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/authentication/#authenticating-proxy",children:"Authenticating Proxy"})]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"All of these examples are useful to set up for an organization or can be used with\nan already in-place solution. More information can be found in their respective\npart of the Kubernetes documentation.\nMost of these are good solutions for productive setups, since they enable easy\nuser management, access revocation and things like short-lived access tokens.\nWhat will be used by your organization depends on the present setup and the use case."}),"\n",(0,i.jsx)(t.h4,{id:"authorization",children:"Authorization"}),"\n",(0,i.jsx)(t.p,{children:"Authorization is done after the authentication step in order to check the rights\nof a user within the system. Kubernetes authorizes API requests with the API server,\nwhich evaluates requests against all policies in place and then allows or denies these requests.\nBy default, a request would be denied."}),"\n",(0,i.jsx)(t.p,{children:"Kubernetes provides several authentication modes to authorize a request:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.em,{children:"Node"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/node/",children:"Node authorization mode"})," grants permission to a Kubelet\nbased on the scheduled pods running on them. It allows a Kubelet to perform specific\nAPI operations. The goal is to have a minimal set of permissions to ensure\nthe Kubelet can operate correctly.\nEach Kubelet identifies with credentials belonging to the ",(0,i.jsx)(t.code,{children:"system:nodes"})," group and\na username ",(0,i.jsx)(t.code,{children:"system:nodes:<node>"})," against this authorizer."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.em,{children:"ABAC (Attribute-based access control)"})}),"\n",(0,i.jsxs)(t.p,{children:["ABAC grants access rights based on policies dependent on attributes like\nuser attributes, resource attributes or environment attributes.\nAn example would be the ",(0,i.jsx)(t.code,{children:"resource"})," attribute, which could limit access for a user\nto only ",(0,i.jsx)(t.code,{children:"Pod"})," resources."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.em,{children:"RBAC (Role-based access control)"})}),"\n",(0,i.jsxs)(t.p,{children:["RBAC is a method of regulating access to the resources based on the roles of\nindividual users. A user therefore must have the ability to perform a specific set\nof tasks with a set of resources based on his role.\nKubernetes implements ",(0,i.jsx)(t.code,{children:"Role"}),"s to accomplish this and binds these with ",(0,i.jsx)(t.code,{children:"Role Binding"}),"s\nto a user in order to specify his permission set."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.em,{children:"Webhook"})}),"\n",(0,i.jsx)(t.p,{children:"Webhook authorization uses an HTTP callback to check the authorization of a user\nagainst a URL provided for this mode. This externalises the authorization part\noutside of Kubernetes."}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Most organizations and deployments work with RBAC, most often due to organizational or\ncustomer-owner-relationship-like structures in place.\nNonetheless, neither ABAC, RBAC nor Webhook authorization can be recommended over the\nother, since this all depends on the use case and required structure of a deployment.\nUsing at least one of these modes is recommended."}),"\n",(0,i.jsx)(t.p,{children:"It is also recommended to enable the Node authorizer in order to limit Kubelet\npermissions to a minimum operational state."}),"\n",(0,i.jsx)(t.h4,{id:"admission-controllers",children:"Admission Controllers"}),"\n",(0,i.jsxs)(t.p,{children:["Admission controllers intercept requests to the Kubernetes API after the\nauthentication and authorization step, which validate and/or mutate the request.\nThis step is limited to ",(0,i.jsx)(t.code,{children:"create"}),", ",(0,i.jsx)(t.code,{children:"modify"})," and ",(0,i.jsx)(t.code,{children:"delete"})," objects as well as custom\nverbs, but other requests are not blocked.\nKubernetes provides multiple admission controllers, some of which are enabled by default."]}),"\n",(0,i.jsxs)(t.p,{children:["One recommended admission controller is the ",(0,i.jsxs)(t.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#noderestriction",children:[(0,i.jsx)(t.code,{children:"NodeRestriction"})," controller"]}),",\nwhich limits the ",(0,i.jsx)(t.code,{children:"Node"})," and ",(0,i.jsx)(t.code,{children:"Pod"})," objects a Kubelet is allowed to modify to their own ",(0,i.jsx)(t.code,{children:"Node"})," or\nobjects that are bound to them. It also disallows updating or removing taints and prevents changing\nor adding labels with a ",(0,i.jsx)(t.code,{children:"node-restriction.kubernetes.io/"})," prefix.\nBe aware that Kubelets will only be limited by this admission controller, if the user credentials\nin the ",(0,i.jsx)(t.code,{children:"system:nodes"})," group begin with a ",(0,i.jsx)(t.code,{children:"system:node:<nodeName>"})," username. Administrators must therefore\nconfigure their Kubelets correctly, if the ",(0,i.jsx)(t.code,{children:"NodeRestriction"})," controller should be fully functional."]}),"\n",(0,i.jsx)(t.h3,{id:"kubelet-access-control",children:"Kubelet access control"}),"\n",(0,i.jsxs)(t.p,{children:["The Kubelet is the node agent that runs on each node. It registers with the API\nserver and ensures, that pods handed over to it are running and healthy according\nto the specification provided to it. The HTTPS endpoint of a Kubelet exposes APIs\nwith varying access to sensitive data and also enables various levels\nof performant operations enabling manipulation of node data and containers.\nThere is also a read-only HTTP endpoint that was used for monitoring a Kubelet and\nits information. This port was also used by applications like ",(0,i.jsx)(t.code,{children:"kubeadm"})," to check\nthe health status of the Kubelet.\nThis port is still available, but it is planned to be ",(0,i.jsx)(t.a,{href:"https://github.com/kubernetes/kubernetes/issues/12968",children:"removed"}),"\nin a future version. At the moment, the port is disabled by default since ",(0,i.jsx)(t.a,{href:"https://github.com/kubernetes/kubernetes/pull/59666",children:"Kubernetes 1.10"}),"\nand shortly later also in ",(0,i.jsx)(t.a,{href:"https://github.com/kubernetes/kubeadm/issues/732",children:(0,i.jsx)(t.code,{children:"kubeadm"})}),".\nDifferent sources recommend disabling this port ",(0,i.jsx)(t.a,{href:"https://www.stigviewer.com/stig/kubernetes/2021-04-14/finding/V-242387",children:"4"})," ",(0,i.jsx)(t.a,{href:"https://docs.datadoghq.com/security/default_rules/cis-kubernetes-1.5.1-4.2.4/",children:"5"})," due to possible\nsecurity risks, but since this standard recommends restricting accessibility of internal ports,\nthis port wouldn't be accessible from external networks.\nIt is nevertheless recommended to keep this port disabled, since Kubernetes also acknowledged\nits risks and plans to remove it."]}),"\n",(0,i.jsxs)(t.p,{children:["By default, the API server does not verify the Kubelets serving certificate and\nrequests to the HTTPS endpoint that are not rejected by other authentication\nmethods are treated as anonymous requests with the combination of name ",(0,i.jsx)(t.code,{children:"system:anonymous"}),"\nand group ",(0,i.jsx)(t.code,{children:"system:unauthenticated"}),".\nThis can be disabled by starting the Kubelet with the flag ",(0,i.jsx)(t.code,{children:"--anonymous-auth=false"}),",\nwhich return ",(0,i.jsx)(t.code,{children:"401 Unauthorized"})," for unauthenticated requests.\nIt is also possible to enable internal authentication methods for the Kubelet.\nPossibilities include X509 client certificates as well as API bearer tokens to\nauthenticate against the Kubelet; details for these methods can be found in the ",(0,i.jsx)(t.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/kubelet-authn-authz/#kubelet-authorization",children:"Kubernetes docs"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["After a request is authenticated, the authorization for it is checked, with the default\nbeing ",(0,i.jsx)(t.code,{children:"AlwaysAllow"}),". Requests should at best be authorized depending on their source,\nso differentiation of access makes sense for the Kubelet; not all users should have\nthe same access rights. How access can be configured and delegated to the Kubernetes\nAPI server can be found in the ",(0,i.jsx)(t.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/kubelet-authn-authz/#kubelet-authorization",children:"Kubernetes docs"}),". The process works like the API request\nauthorization approach with verbs and resources being used as identifiers in roles and role bindings."]}),"\n",(0,i.jsx)(t.h3,{id:"pod-security-policies",children:"Pod security policies"}),"\n",(0,i.jsx)(t.p,{children:'Pod security plays a big part in securing a Kubernetes cluster, since bad actors could use pods to gain\nprivileged access to the systems underneath. The security risk here is mainly influenced by the capabilities\nand privileges given to a container. It is therefore recommended to apply the principal of "least privilege",\nwhich should limit the security risk to a minimum.'}),"\n",(0,i.jsxs)(t.p,{children:["Kubernetes defines the ",(0,i.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/security/pod-security-standards/",children:(0,i.jsx)(t.em,{children:"Pod security standards"})}),"\nin the form of three policies that try to cover the range of the security spectrum.\nThese policies can be found in the following list and define a list of restricted fields that can only be\nchanged to a set of allowed values. An up-to-date list of these values can be found ",(0,i.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/security/pod-security-standards/",children:"here"}),"."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.em,{children:"Privileged"})}),"\n",(0,i.jsx)(t.p,{children:"Unrestricted policy, providing the widest possible level of permissions.\nThis policy allows for known privilege escalations."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.em,{children:"Baseline"})}),"\n",(0,i.jsx)(t.p,{children:"Minimally restrictive policy which prevents known privilege escalations.\nAllows the default (minimally specified) Pod configuration."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.em,{children:"Restricted"})}),"\n",(0,i.jsx)(t.p,{children:"Heavily restricted policy, following current Pod hardening best practices."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Kubernetes also offers the ",(0,i.jsx)(t.em,{children:"Pod security"})," admission controller, which enforces\nthe ",(0,i.jsx)(t.em,{children:"Pod security standards"})," on a namespace level during pod creation.\nThe admission controller defines the standard to be used with the three levels\n",(0,i.jsx)(t.code,{children:"privileged"}),", ",(0,i.jsx)(t.code,{children:"baseline"})," and ",(0,i.jsx)(t.code,{children:"restricted"}),". Each namespace can be configured to enforce\na different control mode, which defines what action the control plane takes\nafter a violation of the selected ",(0,i.jsx)(t.em,{children:"Pod security"})," is detected."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:"enforce"})}),"\n",(0,i.jsx)(t.p,{children:"Policy violations will cause the pod to be rejected."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:"audit"})}),"\n",(0,i.jsx)(t.p,{children:"Policy violations will trigger the addition of an audit annotation to the event\nrecorded in the audit log, but are otherwise allowed."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.code,{children:"warn"})}),"\n",(0,i.jsx)(t.p,{children:"Policy violations will trigger a user-facing warning, but are otherwise allowed."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Be aware, that ",(0,i.jsx)(t.code,{children:"enforce"})," is not applied to workload resources, only to the pods created from their template."]}),"\n",(0,i.jsx)(t.h3,{id:"further-measurements",children:"Further measurements"}),"\n",(0,i.jsxs)(t.p,{children:["While researching this topic, further measurements were considered such as container image verification,\ndistroless images, usage of ",(0,i.jsx)(t.code,{children:"ImagePolicyWebhook"}),", network policy enforcement,\ncontainer sandboxing and prevention of kernel module loading.\nMost of these were taken out of the document during writing due to either being the responsibility\nof the clusters' user (and therefore not possible to implement for the provider), being more relevant\nfor high security clusters or changing the expected cluster environment too much, so that normally\nexpected operations could potentially not work in such a modified cluster.\nThese measurements will possibly be introduced in a future document about higher security clusters."]}),"\n",(0,i.jsx)(t.h2,{id:"standard",children:"Standard"}),"\n",(0,i.jsx)(t.p,{children:"This standard provides the baseline security requirements for a cluster in the SCS context."}),"\n",(0,i.jsxs)(t.p,{children:["Kubernetes clusters MUST be updated regularly in order to receive bugfixes and security patches.\nFor more information refer to the ",(0,i.jsx)(t.a,{href:"/standards/scs-0210-v2-k8s-version-policy",children:"SCS K8s Version Policy"}),",\nwhich outlines the version update policies of the SCS."]}),"\n",(0,i.jsx)(t.p,{children:"Hardening etcd is important due to it being a critical component inside a Kubernetes cluster.\netcd SHOULD be isolated from the Kubernetes cluster by being hosted on separate (virtual) machines.\nIf this is the case, access to these instances MUST be configured, so that only the API server and\nnecessary cluster components requiring access can access etcd.\nCommunication with etcd MUST be secured with TLS for both peer- and cluster-communication.\nIt is RECOMMENDED to use a CA separate from the one used for the Kubernetes cluster for etcd in\norder to better control and issue certificates for clients allowed to access etcd.\nACL MUST be enabled for etcd, which allows better control of the access rights to specific key sets\nfor specific users. Authentication MUST be done via the Common Name (CN) field of the TLS client\ncertificates (since normal username-password-authentication isn't implemented for Kubernetes)."}),"\n",(0,i.jsx)(t.p,{children:"Kubernetes' endpoints MUST be secured in order to provide a small attack surface for bad actors.\nIt MUST NOT be possible to access Kubernetes ports from outside the internal network hosting the\nKubernetes cluster except for the ports of the API server (default 6443) and the NodePort Services\n(default 30000-32767). The read-only Kubelet API port (default 10255), which is mostly used for monitoring,\nSHOULD be disabled altogether if it isn't in use, mainly because the port is HTTP-only\nand can deliver sensitive information to the outside.\nEndpoints MUST be secured via HTTPS."}),"\n",(0,i.jsxs)(t.p,{children:["Securing Kubernetes via authentication and authorization is another important topic here.\nAuthentication is possible through multiple mechanisms, including Kubernetes-provided systems as well as external\nauthentication processes.\nA cluster MUST implement at least two methods for authentication. One of these MUST be ",(0,i.jsx)(t.em,{children:"Service Account Tokens"}),", in order\nto provide full functionality to Pods. A second authentication mechanisms can be chosen depending on the requirements\nof the provider and/or customer."]}),"\n",(0,i.jsxs)(t.p,{children:["Authorization also can be provided through multiple mechanisms.\nA cluster MUST activate at least two authorization methods, one of which MUST be ",(0,i.jsx)(t.em,{children:"Node authorization"})," and another one\nconsisting of either ABAC, RBAC or Webhook authorization depending on the required use case.\nWe RECOMMEND RBAC due to it fitting most use cases and being very well documented, but your setup might require another solution."]}),"\n",(0,i.jsxs)(t.p,{children:["In order to harden Kubelet access control, a Kubelet SHOULD only be accessible internally via HTTPS. This is already the\ncase for the Kubelet API, except for the read-only port, which is only available as HTTP. As mentioned earlier, this port\nshould be disabled.\nKubelets MUST disable anonymous request authentication to disallow non-rejected requests to go through as anonymous requests.\nOPTIONALLY, X509 client certificate authentication or API bearer token authentication can be enabled.\nRequest authorization for the Kubelet MUST be delegated to the API server via ",(0,i.jsx)(t.code,{children:"Webhook"})," authorization as it is recommended\nby the ",(0,i.jsx)(t.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/kubelet-authn-authz/#kubelet-authorization",children:"Kubernetes documentation"}),".\nAdditionally, the ",(0,i.jsx)(t.code,{children:"NodeRestriction"})," admission controller MUST be activated in order to limit interactions between\ndifferent Kubelets by disallowing modification of ",(0,i.jsx)(t.code,{children:"Pod"})," objects, if they're not bound to the Kubelet requesting the modification."]}),"\n",(0,i.jsxs)(t.p,{children:["At last, ",(0,i.jsx)(t.em,{children:"Pod security standards"})," in the form of policies MUST be activated for the cluster. The SCS REQUIRES at least\nthe ",(0,i.jsx)(t.em,{children:"Baseline"})," policy with the ",(0,i.jsx)(t.em,{children:"Restricted"})," policy CAN also be used.\nThe ",(0,i.jsx)(t.em,{children:"Pod security"})," admission controller MUST also be activated in order to enforce these policies on a namespace level.\nWe RECOMMEND the ",(0,i.jsx)(t.code,{children:"enforce"})," level to be used for this admission controller setup."]}),"\n",(0,i.jsx)(t.h2,{id:"conformance-tests",children:"Conformance Tests"}),"\n",(0,i.jsx)(t.p,{children:"Conformance Tests will be written within another issue."}),"\n",(0,i.jsx)(t.h2,{id:"related-documents",children:"Related Documents"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://cheatsheetseries.owasp.org/cheatsheets/Kubernetes_Security_Cheat_Sheet.html",children:"OWASP Kubernetes Security Sheet"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/security/",children:"Kubernetes security concepts"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://kubernetes.io/docs/tasks/administer-cluster/securing-a-cluster/",children:"Securing a cluster"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/security/controlling-access/",children:"Controlling access"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/security/pod-security-standards/",children:"Pod security standards"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://kubernetes.io/blog/2021/10/05/nsa-cisa-kubernetes-hardening-guidance/",children:"NSA CISA Kubernetes hardening"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/",children:"Configure etcd"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://cloud.google.com/kubernetes-engine/docs/concepts/cluster-trust",children:"Google Kubernetes cluster trust"})}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var s=n(96540);const i={},r=s.createContext(i);function o(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);