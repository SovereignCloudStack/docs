"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[61329],{22201:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"scs-0120-v1-capi-images","title":"Cluster-API images","description":"Abstract","source":"@site/standards/scs-0120-v1-capi-images.md","sourceDirName":".","slug":"/scs-0120-v1-capi-images","permalink":"/standards/scs-0120-v1-capi-images","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Cluster-API images","type":"Decision Record","status":"Draft","track":"IaaS"},"sidebar":"standards","previous":{"title":"scs-0120: Cluster-API images","permalink":"/standards/iaas/scs-0120"},"next":{"title":"scs-0121: SCS Availability Zones","permalink":"/standards/iaas/scs-0121"}}');var i=n(74848),a=n(28453);const r={title:"Cluster-API images",type:"Decision Record",status:"Draft",track:"IaaS"},o=void 0,d={},l=[{value:"Abstract",id:"abstract",level:2},{value:"Terminology",id:"terminology",level:2},{value:"Design considerations",id:"design-considerations",level:2},{value:"Decision",id:"decision",level:2},{value:"Consequences",id:"consequences",level:2},{value:"Open questions",id:"open-questions",level:2}];function c(e){const s={a:"a",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.h2,{id:"abstract",children:"Abstract"}),"\n",(0,i.jsx)(s.p,{children:"The SCS reference implementation for the Kubernetes-as-a-service layer is built on top of Cluster API (CAPI), and therefore it depends on the corresponding VM images, which may or may not be present on the underlying infrastructure-as-a-service layer. Current tooling will make sure to upload the required image in case it's not present or outdated. However, these ad-hoc uploads will not be shared across environments, which may lead to waste of bandwidth (for transferring the image), storage (if images are not stored in a deduplicated manner), and not least time (because the upload does take multiple minutes). Needless to say, it may also lead to excessive greenhouse-gas emissions."}),"\n",(0,i.jsx)(s.p,{children:"This decision record investigates the pros and cons of making the CAPI images mandatory. Ultimately, the decision is made to keep them recommended; we stress, however, that providers who offer the images by default should advertise this fact."}),"\n",(0,i.jsx)(s.h2,{id:"terminology",children:"Terminology"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.em,{children:"Kubernetes as a service (KaaS)"}),": A service that offers provisioning Kubernetes clusters."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.em,{children:"Cluster API (CAPI)"}),': "Cluster API is a Kubernetes sub-project focused on providing declarative APIs and tooling to simplify provisioning, upgrading, and operating multiple Kubernetes clusters." (',(0,i.jsx)(s.a,{href:"https://cluster-api.sigs.k8s.io/",children:"source"}),") This API can thus be used to implement KaaS."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.em,{children:"CAPI image"}),": Virtual machine image that contains a standardized Kubernetes setup to be used for CAPI. The SCS reference implementation for KaaS depends on these images."]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.em,{children:"CSP"}),": Cloud-service provider"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"design-considerations",children:"Design considerations"}),"\n",(0,i.jsx)(s.p,{children:"We consider the following two options:"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsx)(s.li,{children:"Make CAPI image mandatory."}),"\n",(0,i.jsx)(s.li,{children:"Keep CAPI image recommended."}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"For reasons of symmetry, it suffices to consider the pros and cons of the first option."}),"\n",(0,i.jsx)(s.p,{children:"Pros:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Save time, money, physical resources and power for both CSP and customer."}),"\n",(0,i.jsx)(s.li,{children:"Regardless of CSP taste, this KaaS tech is part of SCS."}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Neutral:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"The CAPI image can be provided in an automated fashion that means virtually no burden to the CSP."}),"\n",(0,i.jsx)(s.li,{children:"The KaaS implementation will work either way."}),"\n",(0,i.jsx)(s.li,{children:"Willing CSPs may offer the image by default and advertise as much."}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"Cons:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Additional regulations would be necessary to guarantee quality and timeliness of image."}),"\n",(0,i.jsx)(s.li,{children:"Some CSPs may be opposed to being forced to offer a certain service, which may hurt the overall acceptance\nof the SCS standardization efforts."}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"decision",children:"Decision"}),"\n",(0,i.jsx)(s.p,{children:"Ultimately, we value the freedom of the CSPs (and the acceptance of the standardization efforts) highest;\nwilling CSPs are welcome to opt in, i.e., to provide up-to-date images and advertise as much."}),"\n",(0,i.jsxs)(s.p,{children:["Therefore we decide to ",(0,i.jsx)(s.em,{children:"keep the CAPI images recommended"}),"."]}),"\n",(0,i.jsx)(s.h2,{id:"consequences",children:"Consequences"}),"\n",(0,i.jsx)(s.p,{children:"None, as the status quo is being kept."}),"\n",(0,i.jsx)(s.h2,{id:"open-questions",children:"Open questions"}),"\n",(0,i.jsx)(s.p,{children:"Some interesting potential future work does remain, however: to find a way to certify that a willing provider\ndoes indeed provide up-to-date images. It would be possible with today's methods to certify that a CAPI\nimage is present (the image_spec yaml file would have to be split up to obtain a separate test case), but\nwe there is no way to make sure that the image is up to date."})]})}function h(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,s,n)=>{n.d(s,{R:()=>r,x:()=>o});var t=n(96540);const i={},a=t.createContext(i);function r(e){const s=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(a.Provider,{value:s},e.children)}}}]);