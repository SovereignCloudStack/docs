"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[14132],{92947:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"scs-0214-v1-k8s-node-distribution","title":"Kubernetes Node Distribution and Availability","description":"Introduction","source":"@site/standards/scs-0214-v1-k8s-node-distribution.md","sourceDirName":".","slug":"/scs-0214-v1-k8s-node-distribution","permalink":"/standards/scs-0214-v1-k8s-node-distribution","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Kubernetes Node Distribution and Availability","type":"Standard","status":"Deprecated","stabilized_at":"2024-02-08T00:00:00.000Z","deprecated_at":"2024-11-20T00:00:00.000Z","track":"KaaS"},"sidebar":"standards","previous":{"title":"scs-0214: Kubernetes Node Distribution and Availability","permalink":"/standards/kaas/scs-0214"},"next":{"title":"V2","permalink":"/standards/scs-0214-v2-k8s-node-distribution"}}');var s=n(74848),r=n(28453);const o={title:"Kubernetes Node Distribution and Availability",type:"Standard",status:"Deprecated",stabilized_at:new Date("2024-02-08T00:00:00.000Z"),deprecated_at:new Date("2024-11-20T00:00:00.000Z"),track:"KaaS"},a=void 0,d={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Glossary",id:"glossary",level:3},{value:"Motivation",id:"motivation",level:2},{value:"Design Considerations",id:"design-considerations",level:2},{value:"Decision",id:"decision",level:2}];function c(e){const t={a:"a",h2:"h2",h3:"h3",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(t.p,{children:"A Kubernetes instance is provided as a cluster, which consists of a set of machines,\nso-called nodes. A cluster is composed of a control plane and at least one worker node.\nThe control plane manages the worker nodes and therefore the pods in the cluster by making\ndecisions about scheduling, event detection and rights management. Inside the control plane,\nmultiple components exist, which can be duplicated and distributed over multiple nodes\ninside the cluster. Typically, no user workloads are run on these nodes in order to\nseparate the controller component from user workloads, which could pose a security risk."}),"\n",(0,s.jsx)(t.h3,{id:"glossary",children:"Glossary"}),"\n",(0,s.jsx)(t.p,{children:"The following terms are used throughout this document:"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Term"}),(0,s.jsx)(t.th,{children:"Meaning"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Worker"}),(0,s.jsx)(t.td,{children:"Virtual or bare-metal machine, which hosts workloads of customers"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Control Plane"}),(0,s.jsx)(t.td,{children:"Virtual or bare-metal machine, which hosts the container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers."})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Machine"}),(0,s.jsx)(t.td,{children:"Virtual or bare-metal entity with computational capabilities"})]})]})]}),"\n",(0,s.jsx)(t.h2,{id:"motivation",children:"Motivation"}),"\n",(0,s.jsx)(t.p,{children:'In normal day-to-day operation, it is not unusual for some operational failures, either\ndue to wear and tear of hardware, software misconfigurations, external problems or\nuser errors. Whichever was the source of such an outage, it always means down-time for\noperations and users and possible even data loss.\nTherefore, a Kubernetes cluster in a productive environment should be distributed over\nmultiple "failure zones" in order to provide fault-tolerance and high availability.\nThis is especially important for the control plane of the cluster, since it contains the\nstate of the whole cluster. A failure of this component could mean an unrecoverable failure\nof the whole cluster.'}),"\n",(0,s.jsx)(t.h2,{id:"design-considerations",children:"Design Considerations"}),"\n",(0,s.jsxs)(t.p,{children:["Most design considerations of this standard follow the previously written Decision Record\n",(0,s.jsx)(t.a,{href:"https://github.com/SovereignCloudStack/standards/blob/main/Standards/scs-0213-v1-k8s-nodes-anti-affinity.md",children:"Kubernetes Nodes Anti Affinity"})," as well as the Kubernetes documents about\n",(0,s.jsx)(t.a,{href:"https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/",children:"High Availability"})," and ",(0,s.jsx)(t.a,{href:"https://kubernetes.io/docs/setup/best-practices/cluster-large/",children:"Best practices for large clusters"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"SCS wishes to prefer distributed, highly-available systems due to their obvious advantages\nlike fault-tolerance and data redundancy. But it also understands the costs and overhead\nfor the providers associated with this effort, since the infrastructure needs to have\nhardware which will just be used to provide fail-over safety or duplication."}),"\n",(0,s.jsxs)(t.p,{children:["The document ",(0,s.jsx)(t.a,{href:"https://kubernetes.io/docs/setup/best-practices/cluster-large/",children:"Best practices for large clusters"})," describes the concept of a failure zone.\nThis term isn't defined any further, but can in this context be described as a number of\nphysical (computing) machines in such a vicinity to each other (either through physical\nor logical interconnection in some way), that specific problems inside this zone would put\nall these machines at risk of failure/shutdown. It is therefore necessary for important\ndata or services to not be present just on one failure zone.\nHow such a failure zone should be defined is dependent on the risk model of the service/data\nand its owner as well as the capabilities of the provider. Zones could be set from things\nlike single machines or racks up to whole datacenters or even regions, which could be\ncoupled by things like electrical grids. They're therefore purely logical entities, which\nshouldn't be defined further in this document."]}),"\n",(0,s.jsx)(t.h2,{id:"decision",children:"Decision"}),"\n",(0,s.jsx)(t.p,{children:"This standard formulates the requirement for the distribution of Kubernetes nodes in order\nto provide a fault-tolerant and available Kubernetes cluster infrastructure.\nSince some providers only have small environments to work with and therefore couldn't\ncomply with this standard, it will be treated as a RECOMMENDED standard, where providers\ncan OPT OUT."}),"\n",(0,s.jsx)(t.p,{children:"If the standard is used by a provider, the following decisions are binding and valid:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The control plane nodes MUST be distributed over multiple physical machines. Kubernetes\nprovides best-practices on this topic, which are also RECOMMENDED by SCS."}),"\n",(0,s.jsx)(t.li,{children:'At least one control plane instance MUST be run in each "failure zone", more are\nRECOMMENDED in each "failure zone" to provide fault-tolerance for each zone.'}),"\n",(0,s.jsx)(t.li,{children:'Worker nodes are RECOMMENDED to be distributed over multiple zones. This policy makes\nit OPTIONAL to provide a worker node in each "failure zone", meaning that worker nodes\ncan also be scaled vertically first before scaling horizontally.'}),"\n",(0,s.jsx)(t.li,{children:'Worker node distribution MUST be indicated to the user through some kind of labeling\nin order to enable (anti)-affinity for workloads over "failure zones".'}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var i=n(96540);const s={},r=i.createContext(s);function o(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);