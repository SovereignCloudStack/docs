"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[20344],{41031:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"scs-0215-v1-robustness-features","title":"Robustness features for Kubernetes clusters","description":"Introduction","source":"@site/standards/scs-0215-v1-robustness-features.md","sourceDirName":".","slug":"/scs-0215-v1-robustness-features","permalink":"/standards/scs-0215-v1-robustness-features","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Robustness features for Kubernetes clusters","type":"Standard","status":"Draft","track":"KaaS"},"sidebar":"standards","previous":{"title":"scs-0215: Robustness features for Kubernetes clusters","permalink":"/standards/kaas/scs-0215"},"next":{"title":"scs-0216: Requirements for testing cluster-stacks","permalink":"/standards/kaas/scs-0216"}}');var s=n(74848),r=n(28453);const a={title:"Robustness features for Kubernetes clusters",type:"Standard",status:"Draft",track:"KaaS"},o=void 0,c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Glossary",id:"glossary",level:3},{value:"Motivation",id:"motivation",level:2},{value:"Design Considerations",id:"design-considerations",level:2},{value:"Kube-API rate limiting",id:"kube-api-rate-limiting",level:3},{value:"API server flags",id:"api-server-flags",level:4},{value:"Ratelimit Admission Controller",id:"ratelimit-admission-controller",level:4},{value:"Flow control",id:"flow-control",level:4},{value:"etcd maintenance",id:"etcd-maintenance",level:3},{value:"etcd backup",id:"etcd-backup",level:3},{value:"Certificate rotation",id:"certificate-rotation",level:3},{value:"Automatic certificate rotation",id:"automatic-certificate-rotation",level:4},{value:"Decision",id:"decision",level:2},{value:"Kube-API rate limiting",id:"kube-api-rate-limiting-1",level:3},{value:"etcd compaction",id:"etcd-compaction",level:3},{value:"etcd backup",id:"etcd-backup-1",level:3},{value:"Certificate rotation",id:"certificate-rotation-1",level:3},{value:"Related Documents",id:"related-documents",level:2},{value:"Conformance Tests",id:"conformance-tests",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(t.p,{children:"Kubernetes clusters in a productive environment are under the assumption to always perform perfectly without any major\ninterruptions. But due to external or unforeseen influences, clusters can be disrupted in their normal workflow, which\ncould lead to slow responsiveness or even malfunctions.\nIn order to possibly mitigate some problems for the Kubernetes clusters, robustness features should be introduced into\nthe SCS standards. These would harden the cluster infrastructure against several problems, making failures less likely."}),"\n",(0,s.jsx)(t.h3,{id:"glossary",children:"Glossary"}),"\n",(0,s.jsx)(t.p,{children:"The following special terms are used throughout this standard document:"}),"\n",(0,s.jsxs)(t.table,{children:[(0,s.jsx)(t.thead,{children:(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.th,{children:"Term"}),(0,s.jsx)(t.th,{children:"Abbreviation"}),(0,s.jsx)(t.th,{children:"Meaning"})]})}),(0,s.jsxs)(t.tbody,{children:[(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Certificate Authority"}),(0,s.jsx)(t.td,{children:"CA"}),(0,s.jsx)(t.td,{children:"Trusted organization that issues digital certificates entities"})]}),(0,s.jsxs)(t.tr,{children:[(0,s.jsx)(t.td,{children:"Certificate Signing Request"}),(0,s.jsx)(t.td,{children:"CSR"}),(0,s.jsx)(t.td,{children:"Request in order to apply for a digital identity certificate"})]})]})]}),"\n",(0,s.jsx)(t.h2,{id:"motivation",children:"Motivation"}),"\n",(0,s.jsx)(t.p,{children:"A typical productive Kubernetes cluster could be hardened in many different ways, whereas probably many of these actions\nwould overlap and target similar weaknesses of a cluster.\nFor this version of the standard, the following points should be addressed:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"Kube-API rate limiting"}),"\n",(0,s.jsx)(t.li,{children:"etcd compaction/defragmentation"}),"\n",(0,s.jsx)(t.li,{children:"etcd backup"}),"\n",(0,s.jsx)(t.li,{children:"Certificate Authority (CA) expiration avoidance"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:'These robustness features should mainly increase the up-time of the Kubernetes cluster by avoiding downtimes either\nbecause of internal problems or external threads like "Denial of Service" attacks.\nAdditionally, the etcd database should be strengthened with these features in order to provide a secure and robust\nbackend for the Kubernetes cluster.'}),"\n",(0,s.jsx)(t.h2,{id:"design-considerations",children:"Design Considerations"}),"\n",(0,s.jsx)(t.p,{children:"In order to provide a conclusive standard, some design considerations need to be set beforehand:"}),"\n",(0,s.jsx)(t.h3,{id:"kube-api-rate-limiting",children:"Kube-API rate limiting"}),"\n",(0,s.jsx)(t.p,{children:"Rate limiting is the practice of preventing too many requests to the same server in some time frame. This can help prevent\nservice interruptions due to congestion and therefore slow responsiveness or even service shutdown.\nKubernetes suggests multiple ways to integrate such a Ratelimit for its API server, a few of which will be mentioned here.\nIn order to provide a useful Ratelimit for the Kubernetes cluster, combination of these methods should be considered."}),"\n",(0,s.jsx)(t.h4,{id:"api-server-flags",children:"API server flags"}),"\n",(0,s.jsx)(t.p,{children:"The Kubernetes API server has some flags available to limit the amount of incoming requests that will be accepted by\nthe server, which should prevent crashing of the API server. This nevertheless shouldn't be the only measure to\nintroduce a rate limit, since important requests could get blocked during high traffic periods (at least according to\nthe official documentation).\nThe following controls are available to tune the server:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"max-requests-inflight"}),"\n",(0,s.jsx)(t.li,{children:"max-mutating-requests-inflight"}),"\n",(0,s.jsx)(t.li,{children:"min-request-timeout"}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["More details can be found in the following documents:\n",(0,s.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/cluster-administration/flow-control/",children:"Flow Control"})]}),"\n",(0,s.jsx)(t.h4,{id:"ratelimit-admission-controller",children:"Ratelimit Admission Controller"}),"\n",(0,s.jsxs)(t.p,{children:["From version 1.13 onwards, Kubernetes includes a EventRateLimit Admission Controller, which aims to mitigate Ratelimit\nproblems associated with the API server by providing limits for requests every second either to specific resources or\neven the whole API server. If requests are denied due to this Admission Controller, they're either cached or denied\ncompletely and need to be retried; this also depends on the EventRateLimit configuration.\nMore details can be found in the following documents:\n",(0,s.jsx)(t.a,{href:"https://rke.docs.rancher.com/config-options/rate-limiting",children:"Rancher rate limiting"}),"\n",(0,s.jsx)(t.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#eventratelimit",children:"EventRateLimit"}),"\nIt is important to note, that this only helps the API server against event overloads and not necessarily the network\nin front of it, which could still be overwhelmed."]}),"\n",(0,s.jsx)(t.h4,{id:"flow-control",children:"Flow control"}),"\n",(0,s.jsxs)(t.p,{children:["Flow control for the Kubernetes API server can be provided by the API priority and fairness feature, which classifies\nand isolates requests in a fine-grained way in order to prevent an overload of the API server.\nThe package introduces queues in order to not deny requests and dequeue them through Fair Queueing techniques.\nOverall, the Flow control package introduces many different features like request queues, rule-based flow control,\ndifferent priority levels and rate limit maximums.\nThe concept documentation offers a more in-depth explanation of the feature:\n",(0,s.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/cluster-administration/flow-control/",children:"Flow Control"})]}),"\n",(0,s.jsx)(t.h3,{id:"etcd-maintenance",children:"etcd maintenance"}),"\n",(0,s.jsx)(t.p,{children:"etcd is a strongly consistent, distributed key-value store that provides a reliable way to store data that needs to be\naccessed by a distributed system or cluster of machines. For these reasons, etcd was chosen as the default database\nfor Kubernetes.\nIn order to remain reliable, an etcd cluster needs periodic maintenance. This is necessary to maintain the etcd keyspace;\nfailure to do so could lead to a cluster-wide alarm, which would put the cluster into a limited-operation mode.\nTo mitigate this scenario, the etcd keyspace can be compacted. Additionally, an etcd cluster can be defragmented, which\ngives back disk space to the underlying file system and can help bring the cluster back into an operable state, if it\nran out of space earlier."}),"\n",(0,s.jsx)(t.p,{children:"etcd keyspace maintenance can be achieved by providing the necessary flags/parameters to etcd, either via the KubeadmControlPlane or in the\nconfiguration file of the etcd cluster, if it is managed independent of the Kubernetes cluster.\nPossible flags, that can be set for this feature, are:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"auto-compaction-mode"}),"\n",(0,s.jsx)(t.li,{children:"auto-compaction-retention"}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["More information about compaction can be found in the respective etcd documentation\n",(0,s.jsx)(t.a,{href:"https://etcd.io/docs/v3.3/op-guide/maintenance/",children:"etcd maintenance"})]}),"\n",(0,s.jsx)(t.h3,{id:"etcd-backup",children:"etcd backup"}),"\n",(0,s.jsxs)(t.p,{children:["An etcd cluster should be regularly backed up in order to be able to restore the cluster to a known good state at an\nearlier space in time if a failure or incorrect state happens.\nThe cluster should be backed up multiple times in order to have different possible states to go back to. This is especially\nuseful, if data in the newer backups was already corrupted in some way or important data was deleted in them.\nFor this reason, a backup strategy needs to be developed with a decreasing number of backups in an increasing period of time,\nmeaning that the previous year should only have 1 backup, but the current week should have multiple.\nInformation about the backup process can be found in the etcd documentation:\n",(0,s.jsx)(t.a,{href:"https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/",children:"Upgrade etcd"})]}),"\n",(0,s.jsx)(t.h3,{id:"certificate-rotation",children:"Certificate rotation"}),"\n",(0,s.jsxs)(t.p,{children:["In order to secure the communication of a Kubernetes cluster, (TLS) certificates signed by a controlled\nCertificate Authority (CA) can be used.\nNormally, these certificates expire after a set period of time. In order to avoid expiration and failure of a cluster,\nthese certificates need to be rotated regularly and at best automatically.\nCertificates can either be rotated manually (a reference for manually working with certificates can be found\n",(0,s.jsx)(t.a,{href:"https://github.com/kelseyhightower/kubernetes-the-hard-way/blob/79a3f79b27bd28f82f071bb877a266c2e62ee506/docs/04-certificate-authority.md",children:"here"}),")\nor automatically, which requires other things to care about in a deployment."]}),"\n",(0,s.jsxs)(t.p,{children:["Some tools or clusters provide possibilities to rotate certificates manually.\nFor example, ",(0,s.jsx)(t.code,{children:"kubeadm"})," and ",(0,s.jsx)(t.code,{children:"k3s"})," provides the following commands"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"# kubeadm\nkubeadm certs renew all\n\n# k3s\nk3s certificate rotate\n"})}),"\n",(0,s.jsx)(t.p,{children:"A CA might also expire. Unfortunately, not all Kubernetes tools have functionality to renew these certificates.\nInstead, documentation is provided to manually rotating a CA ([Manual rotation of ca certificate])."}),"\n",(0,s.jsx)(t.h4,{id:"automatic-certificate-rotation",children:"Automatic certificate rotation"}),"\n",(0,s.jsxs)(t.p,{children:["kubelet can be configured to obtain properly signed certificates from the ",(0,s.jsx)(t.code,{children:"certificates.k8s.io"})," API of Kubernetes.\nTo do this, set ",(0,s.jsx)(t.code,{children:"serverTLSBootstrap: true"})," in the configuration file of kubelet, which enables both the certificate request\nduring bootstrapping and the rotation mechanism. Setting ",(0,s.jsx)(t.code,{children:"rotateCertificates: true"})," only enables the certificate rotation [Kubeadm certs].\n",(0,s.jsx)(t.code,{children:"--rotate-certificates"})," or ",(0,s.jsx)(t.code,{children:"--rotate-server-certificates"})," shouldn't be used as command line arguments to set these flags,\nsince both parameters are deprecated according to [Certificate rotation]."]}),"\n",(0,s.jsxs)(t.p,{children:["It is also important to note that some Kubernetes clusters or admin tools provide additional ways to rotate certificates.\nFor example, ",(0,s.jsx)(t.code,{children:"kubeadm"})," automatically rotates certificates, if the cluster is updated with the tool (see [Automatic Certificate renewal]).\nThis would also mean, that at least ",(0,s.jsx)(t.code,{children:"kubeadm"}),"-based clusters can be assumed to rotate their certificates regularly,\nsince they would probably be updated within the time period described in the\nstandard ",(0,s.jsx)(t.a,{href:"https://github.com/SovereignCloudStack/standards/tree/main/Standards/scs-0210-v2-k8s-version-policy.md",children:"SCS-0210-v2"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["If an automatic certificate rotation happens, these certificates need to be approved either manually or by a third party\ncontroller like the ",(0,s.jsx)(t.a,{href:"https://github.com/postfinance/kubelet-csr-approver",children:"kubelet csr approver"}),", which can be deployed on\na Kubernetes cluster to automate this process."]}),"\n",(0,s.jsx)(t.p,{children:"A manual approval of these CSRs could be done with the commands"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"kubectl get csr\nkubectl certificate approve <CSR>\n"})}),"\n",(0,s.jsx)(t.p,{children:"in order to complete a certificate rotation.\nBut it should be noted, that this is also most likely dependent on the Kubernetes cluster solution in use."}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"kubectl get csr"})," allows to check, if a CSR needs to be approved; a ",(0,s.jsx)(t.code,{children:"Pending"})," CSR would need to be approved."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-bash",children:"NAME        AGE     SIGNERNAME                        REQUESTOR                      CONDITION\ncsr-9wvgt   112s    kubernetes.io/kubelet-serving     system:node:worker-1           Pending\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Further information and examples can be found in the Kubernetes documentation:\n",(0,s.jsx)(t.a,{href:"https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/",children:"Kubeadm certs"}),"\n",(0,s.jsx)(t.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/",children:"Kubelet TLS bootstrapping"})]}),"\n",(0,s.jsx)(t.h2,{id:"decision",children:"Decision"}),"\n",(0,s.jsx)(t.p,{children:"Robustness features combine multiple aspects of increasing the security, hardness and\nlongevity of a Kubernetes cluster. The decisions will be separated into their respective\nareas."}),"\n",(0,s.jsx)(t.h3,{id:"kube-api-rate-limiting-1",children:"Kube-API rate limiting"}),"\n",(0,s.jsx)(t.p,{children:"The number of requests send to the kube-api or Kubernetes API server MUST be limited\nin order to protect the server against outages, deceleration or malfunctions due to an\noverload of requests.\nIn order to do so, at least the following parameters MUST be set on a Kubernetes cluster:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"max-requests-inflight"}),"\n",(0,s.jsx)(t.li,{children:"max-mutating-requests-inflight"}),"\n",(0,s.jsx)(t.li,{children:"min-request-timeout"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Values for these flags/parameters SHOULD be adapted to the needs of the environment and\nthe expected load."}),"\n",(0,s.jsxs)(t.p,{children:["A cluster MUST also activate and configure a Ratelimit admission controller.\nThis requires an ",(0,s.jsx)(t.code,{children:"EventRateLimit"})," resource to be deployed on the Kubernetes cluster.\nThe following settings are RECOMMENDED for a cluster-wide deployment, but more\nfine-grained rate limiting can also be applied, if this is necessary."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:"kind: Configuration\napiVersion: eventratelimit.admission.k8s.io/v1alpha1\nlimits:\n- burst: 20000\n  qps: 5000\n  type: Server\n"})}),"\n",(0,s.jsx)(t.p,{children:"It is also RECOMMENDED to activate the Kubernetes API priority and fairness feature,\nwhich also uses the aforementioned cluster parameters to better queue, schedule and\nprioritize incoming requests."}),"\n",(0,s.jsx)(t.h3,{id:"etcd-compaction",children:"etcd compaction"}),"\n",(0,s.jsx)(t.p,{children:"etcd MUST be cleaned up regularly, so that it functions correctly and doesn't take\nup too much space, which happens because of its increase of the keyspace."}),"\n",(0,s.jsx)(t.p,{children:"To compact the etcd keyspace, the following flags/parameters MUST be set for etcd:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"auto-compaction-mode = periodic"}),"\n",(0,s.jsx)(t.li,{children:"auto-compaction-retention = 8h"}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"etcd-backup-1",children:"etcd backup"}),"\n",(0,s.jsx)(t.p,{children:"An etcd cluster MUST be backed up regularly. It is RECOMMENDED to adapt\na strategy of decreasing backups over longer time periods, e.g. keeping snapshots every\n10 minutes for the last 120 minutes, then one hourly for 1 day, then one daily for 2 weeks,\nthen one weekly for 3 months, then one monthly for 2 years, and after that a yearly backup.\nAt the very least, a backup MUST be done once a week.\nThese numbers can be adapted to the security setup and concerns like storage or network\nusage. It is also RECOMMENDED to encrypt the backups in order to secure them further.\nHow this is done is up to the operator."}),"\n",(0,s.jsx)(t.h3,{id:"certificate-rotation-1",children:"Certificate rotation"}),"\n",(0,s.jsx)(t.p,{children:"It should be avoided, that certificates expire either on the whole cluster or for single components.\nTo avoid this scenario, certificates MUST be rotated regularly; in the\ncase of SCS, we REQUIRE at least a yearly certificate rotation."}),"\n",(0,s.jsx)(t.p,{children:"It is also RECOMMENDED to renew the CA regularly to avoid an expiration of the CA.\nThis standard doesn't set an exact timeline for a renewal, since it is dependent on lifetime and\ntherefore expiration date of the CA in question."}),"\n",(0,s.jsx)(t.h2,{id:"related-documents",children:"Related Documents"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"https://kubernetes.io/docs/concepts/cluster-administration/flow-control/",children:"Flow Control"}),"\n",(0,s.jsx)(t.a,{href:"https://rke.docs.rancher.com/config-options/rate-limiting",children:"Rate limiting"}),"\n",(0,s.jsx)(t.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#eventratelimit",children:"EventRateLimit"}),"\n",(0,s.jsx)(t.a,{href:"https://etcd.io/docs/v3.3/op-guide/maintenance/",children:"etcd maintenance"}),"\n",(0,s.jsx)(t.a,{href:"https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/",children:"Upgrade etcd"}),"\n",(0,s.jsx)(t.a,{href:"https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/",children:"Kubeadm certs"}),"\n",(0,s.jsx)(t.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/",children:"Kubelet TLS bootstrapping"}),"\n",(0,s.jsx)(t.a,{href:"https://kubernetes.io/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/#certificate-rotation",children:"Certificate rotation"}),"\n",(0,s.jsx)(t.a,{href:"https://kubernetes.io/docs/tasks/tls/manual-rotation-of-ca-certificates/",children:"Manual rotation of ca certificate"}),"\n",(0,s.jsx)(t.a,{href:"https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#automatic-certificate-renewal",children:"Automatic Certificate renewal"})]}),"\n",(0,s.jsx)(t.h2,{id:"conformance-tests",children:"Conformance Tests"}),"\n",(0,s.jsx)(t.p,{children:"Conformance Tests, OPTIONAL"})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var i=n(96540);const s={},r=i.createContext(s);function a(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);