"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[40714],{70984:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"contribute/docs-workflow-explanation","title":"Documentation workflow explanation","description":"The aim within this documentation is to have a good developer experience and a low entry barrier to start with SCS. For this to achieve we think all docs that define the SCS stack and have been developed by the SCS community should be within this documentation framework.","source":"@site/community/contribute/docs-workflow-explanation.md","sourceDirName":"contribute","slug":"/contribute/docs-workflow-explanation","permalink":"/community/contribute/docs-workflow-explanation","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"community","previous":{"title":"Documentation Files Structure","permalink":"/community/contribute/doc-files-structure-guide"},"next":{"title":"Linting Guide","permalink":"/community/contribute/linting-guide"}}');var r=n(74848),i=n(28453);const s={},c="Documentation workflow explanation",a={},d=[{value:"Information Architecture",id:"information-architecture",level:2}];function l(e){const o={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(o.header,{children:(0,r.jsx)(o.h1,{id:"documentation-workflow-explanation",children:"Documentation workflow explanation"})}),"\n",(0,r.jsx)(o.p,{children:"The aim within this documentation is to have a good developer experience and a low entry barrier to start with SCS. For this to achieve we think all docs that define the SCS stack and have been developed by the SCS community should be within this documentation framework."}),"\n",(0,r.jsx)(o.h2,{id:"information-architecture",children:"Information Architecture"}),"\n",(0,r.jsxs)(o.ul,{children:["\n",(0,r.jsxs)(o.li,{children:["\n",(0,r.jsxs)(o.p,{children:["All general docs are located within the ",(0,r.jsx)(o.a,{href:"https://github.com/SovereignCloudStack/docs",children:"SovereignCloudStack/docs"})," repository."]}),"\n"]}),"\n",(0,r.jsxs)(o.li,{children:["\n",(0,r.jsx)(o.p,{children:"Docs that explain, guide or contextualize specific modules such as the openstack-image-manager or the k8s-cluster-api-provider reside within their repository in a seperate docs directory."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(o.p,{children:["Both, the general docs and docs of the external repositories are combined into the one unified documentation collection that is being rendered in a static page on ",(0,r.jsx)(o.a,{href:"https://docs.scs.community",children:"https://docs.scs.community"}),". In order to make this work we have developed a workflow that syncs all doc repositories and distills only the relevant markdown files."]}),"\n",(0,r.jsxs)(o.p,{children:["The script is called ",(0,r.jsx)(o.code,{children:"getDocs"}),". It is a postinstall script and is executed after ",(0,r.jsx)(o.code,{children:"npm install"}),". This has the advantage to have the docs \u2013 coming from the cloud \u2013 in your local docusaurus development environment as well as in the build process."]}),"\n",(0,r.jsxs)(o.p,{children:["You'll find the script in the root directory of the ",(0,r.jsx)(o.a,{href:"https://github.com/SovereignCloudStack/docs-page",children:"SovereignCloudStack/docs-page"})," repository:"]}),"\n",(0,r.jsx)(o.pre,{children:(0,r.jsx)(o.code,{className:"language-js",metastring:'title="getDocs.js"',children:"const fs = require('fs')\nconst { execSync } = require('child_process')\n\n// Read the contents of the \"docs.package.json\" file and remove all whitespace\nconst reposJson = fs\n  .readFileSync('./docs.package.json', 'utf8')\n  .replace(/\\s/g, '')\n\n// Parse the JSON and create an array of repositories\nconst repos = JSON.parse(reposJson)\nconst ghUrl = 'https://github.com/'\n\n// Clone each repository, remove git folders and README files, and copy the docs to the target directory\nrepos.forEach((repo) => {\n  const repoDir = `repo_to_be_edited/${repo.label}`\n\n  // Clone the repository\n  const cloneCommand = `git clone ${ghUrl + repo.repo} ${repoDir}`\n  execSync(cloneCommand)\n\n  // Remove git folders\n  const removeGitCommand = `rm -rf ${repoDir}/.git`\n  execSync(removeGitCommand)\n\n  // Remove README files\n  const removeReadmeCommand = `find ${repoDir} -name \"README.md\" | xargs rm -f`\n  execSync(removeReadmeCommand)\n\n  // Create the docusaurus subdirectory\n  const subDirPath = `${repo.target}/${repo.label}`\n  fs.mkdirSync(subDirPath, { recursive: true })\n\n  // Copy docs content from A to B\n  const copyDocsCommand = `cp -r ${repoDir}/${repo.source} ${subDirPath}`\n  execSync(copyDocsCommand)\n\n  // Remove the cloned repository\n  const removeRepoCommand = 'rm -rf repo_to_be_edited'\n  execSync(removeRepoCommand)\n})\n"})})]})}function h(e={}){const{wrapper:o}={...(0,i.R)(),...e.components};return o?(0,r.jsx)(o,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,o,n)=>{n.d(o,{R:()=>s,x:()=>c});var t=n(96540);const r={},i=t.createContext(r);function s(e){const o=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function c(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(i.Provider,{value:o},e.children)}}}]);